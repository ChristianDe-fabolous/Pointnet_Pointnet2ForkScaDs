# This is a sample Python script.

# Press Umschalt+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
import csv
import os
import laspy as lp
import pandas as pd
import open3d as o3d
from plyfile import PlyData, PlyElement
import numpy as np
import shutil
import argparse
root = '/home/christian/Desktop/ScaDS/PointNet2YanxFork/Pointnet_Pointnet2ForkScaDs/'

def parse_args():
    parser = argparse.ArgumentParser('PreprocessData')
    parser.add_argument('')


def normalize_coordinates(df, point_cloud):
    scale_x = point_cloud.header.scale[0]
    offset_x = point_cloud.header.offset[0]
    scale_y = point_cloud.header.scale[1]
    offset_y = point_cloud.header.offset[1]
    scale_z = point_cloud.header.scale[2]
    offset_z = point_cloud.header.offset[2]
    df['X'] = df['X'] * scale_x + offset_x
    df['Y'] = df['Y'] * scale_y + offset_y
    df['Z'] = df['Z'] * scale_z + offset_z
    return df


def normalize_colors(df):
    color_min = 255
    color_max = 65535
    df['red'] = (df['red'] - color_min) / (color_max - color_min)
    df['green'] = (df['green'] - color_min) / (color_max - color_min)
    df['blue'] = (df['blue'] - color_min) / (color_max - color_min)
    return df


def visualizePointCloudLAZ(filepath):

    las_file = filepath
    point_cloud = lp.read(las_file)
    # Create a new dictionary to hold our data
    data = {}
    for dimension in point_cloud.point_format.dimensions:
        data[dimension.name] = getattr(point_cloud, dimension.name)
    print(data)
    print(len(data))
    # Convert dictionary to pandas DataFrame
    df = pd.DataFrame(data)
    df = normalize_coordinates(df, point_cloud)
    df = normalize_colors(df)

    # Load PointCloud into PCD
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(df[['X', 'Y', 'Z']].values)
    pcd.colors = o3d.utility.Vector3dVector(
        df[['red', 'green', 'blue']].values)
    # show entire point cloud
    o3d.visualization.draw_geometries([pcd])


# Convert ply-files to txt-files
def plyfilesToTextFiles(filepath, destinationpath):
    print('path')
    files = os.listdir(filepath)
    header = ['X', 'Y', 'Z', 'red', 'green', 'blue']

    i = 0
    for file_name in files:
        # Counter for numberofFiles

        file_path = os.path.join(filepath, file_name)
        plydata = PlyData.read(file_path)
        cntDP = len(plydata.elements[0])
        print(file_name[:-4])
        # Write new txt-file

        with open(os.path.join(destinationpath, file_name[:-4] + '.txt'), 'w') as file_txt:
            for dpIndex in range(cntDP):
                tupleValues = [str(value)
                               for value in plydata.elements[0][dpIndex]]
                file_txt.write(", ".join(tupleValues))
                file_txt.write('\n')
        i += 1

    data = {}
    header = ['X', 'Y', 'Z', 'red', 'green', 'blue']
    for index, headerElement in enumerate(header):
        data[headerElement] = np.zeros(cntDP)
        tmpNPArray = np.zeros(len(plydata.elements[0]))
        for dpIndex in range(cntDP):
            data[headerElement][dpIndex] = plydata.elements[0][dpIndex][index]


def visualizePointCloudPLY(filepath):

    plydata = PlyData.read(filepath)

    data = {}
    cntDP = len(plydata.elements[0])
    header = ['X', 'Y', 'Z', 'red', 'green', 'blue']
    for index, headerElement in enumerate(header):
        data[headerElement] = np.zeros(cntDP)
        tmpNPArray = np.zeros(len(plydata.elements[0]))
        for dpIndex in range(cntDP):
            data[headerElement][dpIndex] = plydata.elements[0][dpIndex][index]

    df = pd.DataFrame(data)

    df = normalize_colors(df)
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(df[['X', 'Y', 'Z']].values)
    pcd.colors = o3d.utility.Vector3dVector(
        df[['red', 'green', 'blue']].values)
    # show entire point cloud
    o3d.visualization.draw_geometries([pcd])


def visualizePointCloudTXT(filepath):
    plydata = PlyData.read(filepath)

    data = {}
    cntDP = len(plydata.elements[0])
    header = ['X', 'Y', 'Z', 'red', 'green', 'blue']
    for index, headerElement in enumerate(header):
        data[headerElement] = np.zeros(cntDP)
        tmpNPArray = np.zeros(len(plydata.elements[0]))
        for dpIndex in range(cntDP):
            data[headerElement][dpIndex] = plydata.elements[0][dpIndex][index]

    df = pd.DataFrame(data)

    df = normalize_colors(df)
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(df[['X', 'Y', 'Z']].values)
    pcd.colors = o3d.utility.Vector3dVector(
        df[['red', 'green', 'blue']].values)
    # show entire point cloud
    o3d.visualization.draw_geometries([pcd])


def categorizeFilesBinary(csv_path, source_folder, destination_folder, withTxtEnding):
    # Read the Excel file into a DataFrame
    df = pd.read_csv(csv_path)

    # Iterate through each row in the DataFrame
    for index, row in df.iterrows():
        file_name = row['building_id']
        category = row['Gebäudetyp']

        # Form the source and destination file paths
        if withTxtEnding:
            source_file_path = os.path.join(
                source_folder, f"{file_name}" + '.txt')
        else:
            source_file_path = os.path.join(source_folder, f"{file_name}")

        # Check if the file exists before copying
        if os.path.exists(source_file_path) and isinstance(category, str):
            print(category)
            destination_folder_path = os.path.join(
                destination_folder, category)
            # Create the destination folder if it doesn't exist
            os.makedirs(destination_folder_path, exist_ok=True)

            # Copy the file to the destination folder
            shutil.copy(source_file_path, destination_folder_path)
        # else:
            # print(f"File not found for category: {category} and file name: {file_name}")


def categorizeFiles(csv_path, source_folder, destination_folder, withTxtEnding):
    # Read the Excel file into a DataFrame
    df = pd.read_csv(csv_path)

    # Iterate through each row in the DataFrame
    for index, row in df.iterrows():
        file_name = row['building_id']
        category = row['Gebäudetyp']

        # Form the source and destination file paths
        if withTxtEnding:
            source_file_path = os.path.join(
                source_folder, f"{file_name}" + '.txt')
        else:
            source_file_path = os.path.join(source_folder, f"{file_name}")

        # Check if the file exists before copying
        if os.path.exists(source_file_path) and isinstance(category, str):
            print(category)
            destination_folder_path = os.path.join(
                destination_folder, category)
            # Create the destination folder if it doesn't exist
            os.makedirs(destination_folder_path, exist_ok=True)

            # Copy the file to the destination folder
            shutil.copy(source_file_path, destination_folder_path)
        # else:
            # print(f"File not found for category: {category} and file name: {file_name}")


def changeTxtFilesNamesToStartWithCategory(directory_path):
    for directory in os.listdir(directory_path):
        for file in os.listdir(os.path.join(directory_path, directory)):
            name = directory + file[4:]
            print(file)
            print(directory)
            os.rename(os.path.join(directory_path + '/' + directory, file),
                      os.path.join(directory_path + '/' + directory, f"{name}"))


def get_matching_rows(csv_path, id_column, file_names):
    # Read the CSV file into a DataFrame
    df = pd.read_csv(csv_path)

    # Filter rows based on the given file names
    matching_rows = df[df[id_column].isin(file_names)]

    return matching_rows


def get_text_file_names(directory_path):
    text_files = [file.split('.')[0] for file in os.listdir(directory_path)]
    return text_files

    # Example usage:


def createFileWithAllTxtFileNames(directory_path, fromDirectory):
    with open(os.path.join(directory_path, 'allTxtFileNames.txt'), 'w') as file_txt:
        for directory in os.listdir(os.path.join(directory_path, fromDirectory)):

            for file in os.listdir(os.path.join(os.path.join(directory_path, fromDirectory), directory)):
                print(file)
                file_txt.write(file + '\n')


def findFilesWithLessThanXLines(folder_with_txt_files, line_limit, storeLineCount):
    result_files = []

    # Iterate through files in the folder
    for filename in os.listdir(folder_with_txt_files):
        file_path = os.path.join(folder_with_txt_files, filename)

        # Check if the path is a file and ends with '.txt'
        if os.path.isfile(file_path) and filename.endswith('.txt'):
            # Count the lines in the file
            with open(file_path, 'r') as file:
                line_count = sum(1 for line in file)

            # Check if the file has less than the specified line limit
            if line_count < line_limit:
                if storeLineCount:
                    result_files.append(filename + ',  ' + str(line_count))
                else:
                    result_files.append(filename)

    for i in result_files:
        print(i)

    return result_files


def findFilesInFolderWithLessThanXLines(folderWithTxtDirects, lineLimit):
    result_files = []

    for folder in os.listdir(folderWithTxtDirects):
        # Check if the folder exists

        print(folder)
        # Iterate through files in the folder
        tmp = []
        folderPath = os.path.join(folderWithTxtDirects, folder)
        tmp = findFilesWithLessThanXLines(folderWithTxtDirects)

        for name in tmp:
            result_files.append(name)

        if False:
            for filename in os.listdir(os.path.join(folderWithTxtDirects, folder)):
                file_path = os.path.join(
                    folderWithTxtDirects + '/' + folder, filename)

                # Check if the path is a file and ends with '.txt'

                if os.path.isfile(file_path):
                    print('test')
                    # Count the lines in the file
                    with open(file_path, 'r') as file:
                        line_count = sum(1 for line in file)

                    # Check if the file has less than 1024 lines
                    if line_count < lineLimit:
                        result_files.append(filename)

    print(result_files)

    return result_files

# Example usage:


def addTxtEndingToFiles(directory_path):
    for folder in os.listdir(directory_path):
        for file in os.listdir(os.path.join(directory_path, folder)):
            os.rename(os.path.join(directory_path + '/' + folder, file),
                      os.path.join(directory_path + '/' + folder, file + '.txt'))
            print('test')


def deleteTextFilesFromDirectory(toDeleteArray, directoryToDeleteFrom):
    for directory in os.listdir(directoryToDeleteFrom):
        for file in os.listdir(os.path.join(directoryToDeleteFrom, directory)):
            if file in toDeleteArray:
                os.remove(os.path.join(
                    directoryToDeleteFrom + '/' + directory, file))


def printPandasOfLaz(filepath):
    las_file = filepath
    point_cloud = lp.read(las_file)
    # Create a new dictionary to hold our data
    data = {}
    for dimension in point_cloud.point_format.dimensions:
        data[dimension.name] = getattr(point_cloud, dimension.name)
    print(data)
    print(len(data))
    # Convert dictionary to pandas DataFrame
    df = pd.DataFrame(data)
    df = normalize_coordinates(df, point_cloud)
    df = normalize_colors(df)
    print(df)


def createFileWithFilesNamesFromArray(array, filepathDestination, filenameToWrite):
    with open(filepathDestination + '/' + filenameToWrite, 'w') as f:
        for file in array:
            f.write(file + '\n')


def CreateBinaryClassificator():
    pass

def useStreetSmart(filename, csvpath):
    csvPd = pd.read_csv(csvpath)
    
def createTestTxtFile():
        

def main():
    print('t')

def categorizFilesWithFi


if __name__ == '__main__':

    #    args = parse_args()
 #   main(args)
    if False:
        plyfilesToTextFiles(
            root + 'data/ScaDSdata/buildings_zentrum_nord', root + 'data/ScaDSdata/buildings_zetrum_nord_raw_txt')
    elif False:

        file_names_to_match = get_text_file_names(
            root + 'data/ScaDSdata/buildings_zetrum_nord_raw_txt')
        print(file_names_to_match)
        print(len(file_names_to_match))

    elif False:
        csv_path = root + 'PlyCloudData/Gebäudedatei_Stand_06072023_merged_IDs.csv'
        # Assuming 'ID' is the column in your CSV file that matches the txt file name
        id_column = 'building_id'
        # Replace with the specific file names you want to match
        file_names_to_match = get_text_file_names(
            root + 'data/ScaDSdata/buildings_zetrum_nord_raw_txt')

        # Get matching rows based on IDs
        matching_rows = get_matching_rows(
            csv_path, id_column, file_names_to_match)

        # Write the matching rows to a new CSV file

        matching_rows.to_csv(
            root + 'data/fileLists/FilteredCSVFilesForTXTFiles.csv', index=False)

        filtered_csv_path = root + 'data/fileLists/FilteredCSVFilesForTXTFiles.csv'
        categorizeFiles(filtered_csv_path, source_folder=root + 'data/ScaDSdata/buildings_zetrum_nord_raw_txt',
                        destination_folder=root + 'data/ScaDSdata/buildings_zentrum_nord_txt_categorized_and_filtered', withTxtEnding=True)
    elif False:
        createFileWithAllTxtFileNames('/home/christian/Schreibtisch/PointNetData',
                                      fromDirectory='txtCloudFilesInTypes (Kopie) ohne txt Endung min 1024 Lines')
    elif True:
        changeTxtFilesNamesToStartWithCategory(
            root + 'data/ScaDSdata/buildings_zentrum_nord_txt_categorized')
    elif False:
        result = find_files_with_less_than_X_lines(
            '/home/christian/Schreibtisch/PointNetData/txtCloudFilesInTypes (Kopie) ohne txt Endung', 1024)
        print(result)
        print(len(result))

        deleteTextFilesFromDirectory(
            result, '/home/christian/Schreibtisch/PointNetData/txtCloudFilesInTypes (Kopie) ohne txt Endung min 1024 Lines')
    elif False:
        addTxtEndingToFiles(
            '/home/christian/Schreibtisch/PointNetData/txtCloudFilesInTypes (Kopie) ohne txt Endung min 1024 Lines')

    elif False:
        printPandasOfLaz(
            root + 'data/ScaDSdata/Nord/de-leip-220422_part_00_00/filtered_6344_113830.laz')
    elif False:
        result = findFilesWithLessThanXLines(
            root + 'data/ScaDSdata/buildings_zetrunm_nord_txt', 1024, True)
        createFileWithFilesNamesFromArray(
            result, root + 'data/fileLists', 'allTxtFileNamesLess1024')
    elif False:
        categorizeFiles(root + 'PlYCloudData/Gebäudedatei_Stand_06072023_merged_IDs.csv',
                        root + 'data/ScaDSdata/buildings_zetrunm_nord_txt', )
